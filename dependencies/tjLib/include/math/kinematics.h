#include <cassert>
#include <iostream>
#include <vector>

#include "EigenWrapper.h"
#include "vector_math.h"
/**
 * @brief computes intermediate orientations generated by a sequence of body
 * angular velocities over times t
 *
 * @param t vector of timestamps
 * @param w_b vector of body angular velocities [rad/sec]
 * @param ori_0 inital orientation
 * @return vector of orientations. Interpret them as:
          orientations[n].as_matrix() transforms a vector with coordinates
          in the Nth body frame to coordinates in the initial frame
 */
std::vector<Quaternion> integrate_body_angular_velocities(vectord t, std::vector<Vector3> w_b,
                                                          Quaternion ori_0 = Quaternion::Identity());
/**
 * @brief *Given a sequence of N orienations which transform vectors from
 * different frames to a common reference frame, find the realtive orientations
 * between sucessive frames:
 *
 * @param orientations orientaitons to be differenced
 * @return std::vector<Quaternion> differenced orientations
 *
 * Example:
 *  If "orientations" is a series of body-to-inertial frame rotations:
 *      [inertial_R_body0, inertial_R_body1, inertial_R_body2, inertial_R_body3]
 *
 *  this function returns:
 *      [body0_R_body1, body1_R_body2, body2_R_body3]
 */
std::vector<Quaternion> diffOrientations(std::vector<Quaternion> orientations);
/**
 * @brief Given an initial rotation and a sequence of N rotations which
 * transform vectors between sucessive frames, find the accumulated rotation
 * from the initial frame
 *
 * @param R0 initial rotation
 * @param rotations sequence of rotations to be integrated
 * @return std::vector<Quaternion> integrated rotations
 *
 *  Example:
 *  If "rotations" is a series of body-to-body frame rotations:
 *      [body0_R_body1, body1_R_body2, body2_R_body3]
 *
 *  this function returns:
 *      [R0 * body0_R_body1, R0 * body0_R_body1 * body1_R_body2, R0 *
 * body0_R_body1 * body1_R_body2 * body2_R_body3]
 *      = [R0 * body0_R_body1, R0 * body0_R_body2, R0 * body0_R_body3]
 */
std::vector<Quaternion> integrateRotations(Quaternion R0, std::vector<Quaternion> rotations);
